//////////////////////////////////////////////////////////////////////////
// DependencyAnalysis.cs - To Identify dependencies among files         //
// ver 1.0                                                              //
// Language:    C#, 2017, .Net Framework 4.7.1                          //
// Platform:    Dell Precision T8900, Win10                             //
// Anish Nesarkar , CSE 681 - Software Modelling and Analysis, Fall2018 //
// Source Author:      Jim Fawcett, CST 4-187, Syracuse University      //
//////////////////////////////////////////////////////////////////////////
/*
 * Package Operations:
 * -------------------
 * This package takes input the type table generated by Type Analysis package
 * It finds dependencies between the files based on namespaces, using and alias.
 * Parses twice to get the dependencies.
 * Passes the found dependecies to Graph class for finding strongly connected components
 */
/* Required Files:
 *   TypeAnalysis.cs
 *   Semi.cs
 *   Element.cs
 *   CsGraph.cs
 *   ITokenCollection.cs
 *   Executive.cs
 *   
 *   Public Interface Documentaion
 *   =============================
 *   public class DependencyCheck                                                                                                                                                                       // A class that has three data structures
 *   public static class GetTypes                                                                                                                                                                       // class that gives the types namespace, using and alias
 *   public static List<string> ClassList(string filename, List<List<Elem>> listOfTable)                                                                                                                // function to create list of classes
 *   public static List<string> structList(string filename, List<List<Elem>> listOfTable)                                                                                                               // function to create list of structs
 *   public static List<string> EnumList(string filename, List<List<Elem>> listOfTable)                                                                                                                 // function to create list of enums
 *   public static List<string> InterfaceList(string filename, List<List<Elem>> listOfTable)                                                                                                            // function to create list of interface
 *   public static List<string> InterfaceList(string filename, List<List<Elem>> listOfTable)                                                                                                            // 
 *   public static class SecondParse                                                                                                                                                                    // class to parse second time to check dependency
 *   public static void secondParse(string firstFile, string SecondFile, List<List<Elem>> listOfTables, List<string> files, List<Tuple<string, string>> graph)                                          // function to parse second time to check dependency
 *   public static bool ParseForClass(string firstFile, string SecondFile, ITokenCollection semi,List<List<Elem>> listOfTables, List<Tuple<string, string>> graph)                                      // check for class object in second parse
 *   public static bool ParseForInterface(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string,string>> graph)                                  // check for Interface usage in second parse
 *   public static bool ParseForStruct(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string,string>> graph)                                     // check for struct usage in second parse
 *   public static bool ParseForEnum(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables,List<Tuple<string,string>> graph)                                        // check for enum usage in second parse
 *   public static bool ParseForDelegate(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string, string>> graph)
 *   public class DependencyAnalysis                                                                                                                                                                    // Class for Dependency analysis
 *   public static List<CsNode<string, string>> GetDependency(List<List<Elem>> listOfTable, List<string> files)                                                                                         // class to get dependency
 *   public static List<DependencyCheck> Getnamespace(List<List<Elem>> listOfTable)                                                                                                                     // function to get namespaces
 *   public static List<DependencyCheck> Getusing(List<List<Elem>> listOfTable)                                                                                                                         // funtion to get "using"
 *   public static void checkDependencyNamespace(List<DependencyCheck> nspaceList, List<List<Elem>> listOfTables, List<string> file, List<Tuple<string, string>> graph)                                 // check dependency based on namespaces
 *   public static void checkDependencyUsing(List<DependencyCheck> nspaceList, List<DependencyCheck> usingList, List<List<Elem>> listOfTables, List<string> file, List<Tuple<string, string>> graph)    // check dependency based on using
 *   public static void checkDependencyAlias(List<DependencyCheck> nspaceList, List<DependencyCheck> usingList, List<List<Elem>> listOfTables, List<string> file,List<Tuple<string,string>> graph)      // check dependency based on alias
 *   public class DependencyTest
 * Maintenance History:
 * --------------------
 * ver 1.1 : 03 Nov 2018
 * Update - Delegate function has been added to Secondparser to check file dependency based on delegates
 * Function to find List of Delegates and parsing the file to check for delegate instance
 */
using System;
using System.Collections.Generic;
using System.Linq;
using sccGraph;
using System.Text;
using System.Threading.Tasks;
using CodeAnalysis;
using Lexer;
using System.IO;

namespace DependencyAnalyzer
{ 
    public class DependencyCheck  
    {
        public string Typename { get; set; }
        public string Filename { get; set; }
        public string AliasName { get; set; }
    }

    public static class GetTypes
    {
        //-----------------< Generates class lists if the file is dependent >---------
        public static List<string> ClassList(string filename, List<List<Elem>> listOfTable)
        {
            List<string> listOfClass = new List<string>();
            foreach (List<Elem> table in listOfTable)
                foreach (Elem e in table)
                {
                    if (e.filename == filename && e.type == "class")
                        listOfClass.Add(e.name);
                }
            return listOfClass;
        }

        //-----------------< Generates struct lists if the file is dependent >---------
        public static List<string> structList(string filename, List<List<Elem>> listOfTable)
        {
            List<string> listOfstruct = new List<string>();
            foreach (List<Elem> table in listOfTable)
                foreach (Elem e in table)
                {
                    if (e.filename == filename && e.type == "struct")
                        listOfstruct.Add(e.name);
                }
            return listOfstruct;
        }

        //-----------------< Generates Enum lists if the file is dependent >---------
        public static List<string> EnumList(string filename, List<List<Elem>> listOfTable)
        {
            List<string> listOfEnum = new List<string>();
            foreach (List<Elem> table in listOfTable)
                foreach (Elem e in table)
                {
                    if (e.filename == filename && e.type == "enum")
                        listOfEnum.Add(e.name);
                }

            return listOfEnum;
        }

        //-----------------< Generates Interface lists if the file is dependent >---------
        public static List<string> InterfaceList(string filename, List<List<Elem>> listOfTable)
        {
            List<string> listOfInterface = new List<string>();
            foreach (List<Elem> table in listOfTable)
                foreach (Elem e in table)
                {
                    if (e.filename == filename && e.type == "interface")
                        listOfInterface.Add(e.name);
                }

            return listOfInterface;
        }

        //-----------------< Generates Delegate lists if the file is dependent >---------
        public static List<string> delegateList(string filename, List<List<Elem>> listOfTable)
        {
            List<string> listOfDelegate = new List<string>();
            foreach (List<Elem> table in listOfTable)
                foreach (Elem e in table)
                {
                    if (e.filename == filename && e.type == "delegate")
                        listOfDelegate.Add(e.name);
                }

            return listOfDelegate;
        }
    }

    public static class SecondParse
        {
        //-----------------< Second parse function to check for dependency >---------
        public static void secondParse(string firstFile, string SecondFile, List<List<Elem>> listOfTables, List<string> files, List<Tuple<string, string>> graph)
        {
                ITokenCollection semi = Factory.create();
                string secondFilepath = null;
                foreach (var file in files)
                {
                    if (file.Contains(SecondFile))
                    {
                        secondFilepath = file;
                        break;
                    }
                }
            if (!semi.open(secondFilepath as string))
            {
                Console.Write("\n Can't open {0}\n\n", SecondFile);
            }
                while (true)
                {
                    if (SecondParse.ParseForClass(firstFile, SecondFile, semi, listOfTables,graph))
                        break;
                    semi.open(secondFilepath as string);
                    if (SecondParse.ParseForInterface(firstFile, SecondFile, semi, listOfTables,graph))
                        break;
                    semi.open(secondFilepath as string);
                    if (SecondParse.ParseForStruct(firstFile, SecondFile, semi, listOfTables,graph))
                        break;
                    semi.open(secondFilepath as string);
                    if (SecondParse.ParseForEnum(firstFile, SecondFile, semi, listOfTables, graph))
                        break;
                    semi.open(secondFilepath as string);
                    if (SecondParse.ParseForDelegate(firstFile, SecondFile, semi, listOfTables, graph))
                        break;
                    break;
                }           
        }

        //-----------------< Parse the second file to check for class instance >---------
        public static bool ParseForClass(string firstFile, string SecondFile, ITokenCollection semi,List<List<Elem>> listOfTables, List<Tuple<string, string>> graph)
        {
            List<string> listofClass = new List<string>();
            listofClass = GetTypes.ClassList(firstFile, listOfTables);
            int n = listofClass.Count;
            while (semi.get().Count > 0)
            {
                for (int i = 0; i < n; i++)
                {
                    if (semi.Contains(listofClass[i]))
                    {
                        graph.Add(new Tuple<string, string>(SecondFile, firstFile));
                        return true;
                    }
                }
            }
            return false;
        }

        //-----------------< Parse the second file to check for interface instance >---------
        public static bool ParseForInterface(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string,string>> graph)
        {
            List<string> listofInterface = new List<string>();
            listofInterface = GetTypes.InterfaceList(firstFile, listOfTables);
            int n = listofInterface.Count;
            
            while (semi.get().Count > 0)
            {
                for (int i = 0; i < n; i++)
                {

                    if (semi.Contains(listofInterface[i]))
                    {
                        graph.Add(new Tuple<string, string>(SecondFile, firstFile));
                        return true;
                    }
                }
            }
            return false;
            
        }

        //-----------------< Parse the second file to check for struct instance >---------
        public static bool ParseForStruct(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string,string>> graph)
        {
            List<string> listofStruct = new List<string>();
            listofStruct = GetTypes.structList(firstFile, listOfTables);
            int n = listofStruct.Count;
            
            while (semi.get().Count > 0)
            {
                for (int i = 0; i < n; i++)
                {

                    if (semi.Contains(listofStruct[i]))
                    {
                        graph.Add(new Tuple<string, string>(SecondFile, firstFile));
                        return true;
                    }
                }
            }
            return false;
        }

        //-----------------< Parse the second file to check for enum instance >---------
        public static bool ParseForEnum(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables,List<Tuple<string,string>> graph)
        {
            List<string> listofEnum = new List<string>();
            listofEnum = GetTypes.EnumList(firstFile, listOfTables);
            int n = listofEnum.Count;
            
            while (semi.get().Count > 0)
            {
                for (int i = 0; i < n; i++)
                {
                    if (semi.Contains(listofEnum[i]))
                    {
                        graph.Add(new Tuple<string, string>(SecondFile, firstFile));
                        return true;
                    }
                }
            }
            return false;
            
        }

        //-----------------< Parse the second file to check for delegate instance >---------
        public static bool ParseForDelegate(string firstFile, string SecondFile, ITokenCollection semi, List<List<Elem>> listOfTables, List<Tuple<string, string>> graph)
        {
            List<string> listofDelegates = new List<string>();
            listofDelegates = GetTypes.delegateList(firstFile, listOfTables);
            int n = listofDelegates.Count;

            while (semi.get().Count > 0)
            {
                for (int i = 0; i < n; i++)
                {
                    if (semi.Contains(listofDelegates[i]))
                    {
                        graph.Add(new Tuple<string, string>(SecondFile, firstFile));
                        return true;
                    }
                }
            }
            return false;

        }
    }
    public class DependencyAnalysis
    {
        //-----------------< Function to check for dependency between files >---------
        public static List<CsNode<string, string>> GetDependency(List<List<Elem>> listOfTable, List<string> files)
        {
            List<CsNode<string, string>> nodes = new List<CsNode<string, string>>();
            List<CsNode<string, string>> sccNodes = new List<CsNode<string, string>>();
            var graph = new List<Tuple<string, string>>();
            List<DependencyCheck> usingList = new List<DependencyCheck>();
            List<DependencyCheck> nspaceList = new List<DependencyCheck>();
            nspaceList = Getnamespace(listOfTable);
            usingList = Getusing(listOfTable);
            GraphTest gt = new GraphTest();
            checkDependencyUsing(nspaceList, usingList, listOfTable, files, graph);
            checkDependencyNamespace(nspaceList, listOfTable, files, graph);
            checkDependencyAlias(nspaceList, usingList, listOfTable, files, graph);
            Console.WriteLine();          
            nodes = gt.getGraph(graph, files);           
            return nodes;
        }

        //-----------------< Function to get namespaces of a file >---------
        public static List<DependencyCheck> Getnamespace(List<List<Elem>> listOfTable)
    {
        List<DependencyCheck> namespaceList = new List<DependencyCheck>();
        DependencyCheck store;
        foreach (List<Elem> table in listOfTable)
        {
            foreach (Elem e in table)
            {
                if (e.type == "namespace")
                {
                    store = new DependencyCheck();
                    store.Typename = e.name;
                    store.Filename = e.filename;
                    namespaceList.Add(store);
                }
            }
        }
        return namespaceList;
    }

        //-----------------< Function to get "using" of a file >---------
        public static List<DependencyCheck> Getusing(List<List<Elem>> listOfTable)
        {
            List<DependencyCheck> usingList = new List<DependencyCheck>();
            DependencyCheck store;
            foreach (List<Elem> table in listOfTable)
            {
                foreach (Elem e in table)
                {
                    if (e.type == "using" || e.type == "alias")
                    {
                        store = new DependencyCheck();
                        store.Typename = e.name;
                        store.Filename = e.filename;
                            if (e.type == "alias" && !e.aliasName.StartsWith("System"))
                                store.AliasName = e.aliasName;
                        usingList.Add(store);
                    }
                }
            }
        return usingList;
    }

        //-----------------< Function to check dependency based on namespaces >---------
        public static void checkDependencyNamespace(List<DependencyCheck> nspaceList, List<List<Elem>> listOfTables, List<string> file, List<Tuple<string, string>> graph)
        {           
            for (int j = 0; j < nspaceList.Count; j++)
            {
                for (int i = 0; i < nspaceList.Count; i++)
                {
                    if (nspaceList[j].Typename == nspaceList[i].Typename && j != i)
                    {
                        SecondParse.secondParse(nspaceList[j].Filename, nspaceList[i].Filename, listOfTables, file,graph);
                    }
                }
            }
        }

        //-----------------< Function to check dependency based on using >---------
        public static void checkDependencyUsing(List<DependencyCheck> nspaceList, List<DependencyCheck> usingList, List<List<Elem>> listOfTables, List<string> file, List<Tuple<string, string>> graph)
        {
            for (int j = 0; j < nspaceList.Count; j++)
            {
                for (int k = 0; k < usingList.Count; k++)
                {
                    if (nspaceList[j].Typename == usingList[k].Typename)
                    {
                        SecondParse.secondParse(nspaceList[j].Filename, usingList[k].Filename, listOfTables, file,graph);
                    }
                }              
            }
        }

        //-----------------< Function to check dependency based on alias >---------
        public static void checkDependencyAlias(List<DependencyCheck> nspaceList, List<DependencyCheck> usingList, List<List<Elem>> listOfTables, List<string> file,List<Tuple<string,string>> graph)
        {
            for (int j = 0; j < nspaceList.Count; j++)
            {
                for (int k = 0; k < usingList.Count; k++)
                {
                    if (nspaceList[j].Typename == usingList[k].AliasName)
                    {
                        SecondParse.secondParse(nspaceList[j].Filename, usingList[k].Filename, listOfTables, file,graph);
                    }
                }
            }
        }
    }

    public class DependencyTest
    {

#if (DEPENDENCY_TEST)

        static List<string> ProcessCommandline(string[] args)
        {
            List<string> files = new List<string>();
            string fullpath = Path.GetFullPath(args[0]);
            if (Directory.Exists(fullpath))
            {
                string fileFormat = "cs";
                DirectoryInfo dir = new DirectoryInfo(fullpath);
                foreach (FileInfo file in dir.GetFiles("*." + fileFormat + "*", SearchOption.AllDirectories))
                {
                    files.Add(file.FullName);
                }
            }
            return files;
        }

        static public void showDependencies(List<CsNode<string, string>> nodes)
        {
            foreach (var node in nodes)
            {
                Console.Write("\n File  {0} depends on Files : ", node.name);
                for (int i = 0; i < node.children.Count; ++i)
                {
                    Console.Write("\n       {0}: {1}", (i + 1), node.children[i].targetNode.name);
                }
                Console.WriteLine();
            }
        }

        public static void displayRequirement2(List<CsNode<string, string>> nodes)
        {
            Console.WriteLine("Dependency Analysis for the files: ");
            showDependencies(nodes);
        }

        static void Main(string[] args)
        {
            List<CsNode<string, string>> nodes = new List<CsNode<string, string>>();
            List<List<Elem>> listOfTables = new List<List<Elem>>();
            Console.WriteLine("<------------------------------ Dependency Analysis Test Stub ----------------------->");
            Console.WriteLine();
            List<string> files = ProcessCommandline(args);
            TypeAnalysis typeAnalysisObj = new TypeAnalysis(files);
            listOfTables = typeAnalysisObj.generateTypeTable();
            nodes = DependencyAnalysis.GetDependency(listOfTables, files);
            displayRequirement2(nodes);
            Console.ReadLine();
        }
#endif
    }
    
}

